import { NextApiRequest, NextApiResponse } from "next";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { createMcpServer } from "../../utils/mcp-setup";
import logger from "../../utils/logger";

// Global storage for active transports
// This allows us to route POST messages to the correct SSE connection
// Note: This only works in a single-process environment (like default Next.js dev/start)
const globalWithMcp = global as typeof globalThis & {
    mcpTransports: Map<string, SSEServerTransport>;
};

if (!globalWithMcp.mcpTransports) {
    globalWithMcp.mcpTransports = new Map();
}

export const config = {
    api: {
        // Disable body parsing so the MCP SDK can handle the raw request stream
        bodyParser: false,
        // Increase timeout for long-running SSE connections?
        // Next.js default is usually fine for keep-alive, but verify platform limits.
        // externalResolver: true, // might be needed to avoid warnings
    },
};

export default async function handler(req: any, res: any) {
    // Use 'any' for req/res to avoid strict modification of Next types vs Node types
    // though NextApiRequest extends IncomingMessage usually.

    if (req.method === "GET") {
        logger.info("New MCP SSE connection request");

        // Create new transport bound to this response
        // The endpoint argument is where the client should send POST messages
        const transport = new SSEServerTransport("/api/mcp", res);
        const server = createMcpServer();

        await server.connect(transport);

        // Access the session ID generated by the transport
        // Using 'any' cast because sessionId is sometimes protected/private in different versions,
        // but essential for this pattern. Checks show distinct sessionId property in SDK.
        const sessionId = (transport as any).sessionId;

        if (sessionId) {
            logger.info(`Registered MCP session: ${sessionId}`);
            globalWithMcp.mcpTransports.set(sessionId, transport);
        } else {
            logger.error("Failed to retrieve sessionId from transport");
        }

        // Cleanup when client disconnects
        req.on("close", () => {
            if (sessionId) {
                logger.info(`Closed MCP session: ${sessionId}`);
                globalWithMcp.mcpTransports.delete(sessionId);
            }
        });

        // We do NOT call res.end() here, as the transport keeps the SSE stream open
        return;
    }

    if (req.method === "POST") {
        // Delegate to transport
        const sessionId = req.query.sessionId as string;

        if (!sessionId) {
            res.status(400).end("Missing sessionId");
            return;
        }

        const transport = globalWithMcp.mcpTransports.get(sessionId);
        if (!transport) {
            logger.warn(`Session not found: ${sessionId}`);
            res.status(404).end("Session not found");
            return;
        }

        // Delegate message handling to the transport
        await transport.handlePostMessage(req, res);
        return;
    }

    res.status(405).end("Method not allowed");
}
